<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>EBC – Cyber Neural Build</title>

<style>
body{
margin:0;
font-family:Arial, sans-serif;
background:#04070f;
color:white;
text-align:center;
overflow:hidden;
}

/* Neural Grid Background */
body::before{
content:"";
position:fixed;
width:200%;
height:200%;
background-image:
linear-gradient(rgba(0,255,200,0.05) 1px, transparent 1px),
linear-gradient(90deg, rgba(0,255,200,0.05) 1px, transparent 1px);
background-size:40px 40px;
animation:gridMove 25s linear infinite;
z-index:-1;
}

@keyframes gridMove{
from{transform:translate(0,0);}
to{transform:translate(-200px,-200px);}
}

.card{
width:95%;
max-width:420px;
margin:20px auto;
padding:20px;
background:rgba(255,255,255,0.05);
border-radius:20px;
backdrop-filter:blur(10px);
box-shadow:0 0 25px rgba(0,255,200,0.15);
transition:0.4s;
}

.card.success{
box-shadow:0 0 60px rgba(0,255,150,0.6);
}

.card.fail{
box-shadow:0 0 60px rgba(255,0,60,0.6);
}

button{
padding:12px 24px;
border:none;
border-radius:10px;
background:#00ffd0;
color:black;
font-weight:bold;
cursor:pointer;
box-shadow:0 0 15px #00ffd0;
}

canvas{
margin-top:10px;
background:#0b1324;
border-radius:12px;
touch-action:none;
}

.progress{
height:6px;
background:#222;
margin-top:10px;
border-radius:4px;
overflow:hidden;
}

.progressBar{
height:100%;
width:0%;
background:yellow;
}

#result{
margin-top:15px;
font-size:20px;
font-weight:bold;
letter-spacing:1px;
}

#badge{
margin-top:5px;
font-size:14px;
color:#00ffd0;
opacity:0.8;
}

#challengeScore{
margin-top:8px;
font-size:14px;
opacity:0.8;
}

</style>
</head>
<body>

<div class="card" id="card">

<h2 style="color:#00ffd0">EBC – Verification Engine</h2>
<button onclick="startTest()">Run Verification</button>
  <button id="enableMotion" style="display:none;margin-top:10px;">
Enable Motion Sensors (iPhone)
</button>

<div class="progress">
<div id="bar" class="progressBar"></div>
</div>

<canvas id="challenge" width="320" height="120"></canvas>
<canvas id="graphX" width="320" height="60"></canvas>
<canvas id="graphY" width="320" height="60"></canvas>
<canvas id="graphZ" width="320" height="60"></canvas>

<div id="xyz">X:0 | Y:0 | Z:0</div>

<div id="result"></div>
<div id="badge"></div>
<div id="challengeScore"></div>

</div>

<script>

let collecting=false;
let xArr=[],yArr=[],zArr=[];
let duration=5000;
let points=[];
let challengeLine={x1:40,y1:100,x2:280,y2:20};
function isIOS(){
return /iPhone|iPad|iPod/i.test(navigator.userAgent);
}

window.addEventListener("load",function(){
if(isIOS() && typeof DeviceMotionEvent.requestPermission === "function"){
document.getElementById("enableMotion").style.display="inline-block";
}
});

document.getElementById("enableMotion").addEventListener("click",function(){
DeviceMotionEvent.requestPermission()
.then(response=>{
if(response==="granted"){
alert("Sensors Enabled ✅");
this.style.display="none";
}else{
alert("Permission Denied ❌");
}
})
.catch(console.error);
});
function startTest(){
collecting=true;
xArr=[];yArr=[];zArr=[];points=[];
document.getElementById("result").innerHTML="";
document.getElementById("badge").innerHTML="";
document.getElementById("challengeScore").innerHTML="";
document.getElementById("card").classList.remove("success","fail");
animateBar();
drawChallenge();
setTimeout(()=>{collecting=false;analyze();},duration);
}

function animateBar(){
let start=Date.now();
let interval=setInterval(()=>{
let p=(Date.now()-start)/duration*100;
document.getElementById("bar").style.width=p+"%";
if(p>=100) clearInterval(interval);
},50);
}

window.addEventListener("devicemotion",function(e){
if(!collecting||!e.acceleration)return;

let x=e.acceleration.x||0;
let y=e.acceleration.y||0;
let z=e.acceleration.z||0;

xArr.push(x);
yArr.push(y);
zArr.push(z);

drawGraphs();
document.getElementById("xyz").innerHTML=
"X:"+x.toFixed(2)+" | Y:"+y.toFixed(2)+" | Z:"+z.toFixed(2);
});

function analyze(){

function stdDev(arr){
let mean = arr.reduce((a,b)=>a+b,0)/arr.length;
let variance = arr.reduce((a,b)=>a+Math.pow(b-mean,2),0)/arr.length;
return Math.sqrt(variance);
}

function zeroCrossings(arr){
let count=0;
for(let i=1;i<arr.length;i++){
if((arr[i-1]>=0 && arr[i]<0) || (arr[i-1]<0 && arr[i]>=0)){
count++;
}
}
return count;
}

if(xArr.length < 10){
document.getElementById("result").innerHTML="NOT ENOUGH DATA";
return;
}

/* --- 1. Standard Deviation --- */
let stdX = stdDev(xArr);
let stdY = stdDev(yArr);
let stdZ = stdDev(zArr);
let avgStd = (stdX + stdY + stdZ)/3;

/* --- 2. Zero Crossing --- */
let zcX = zeroCrossings(xArr);
let zcY = zeroCrossings(yArr);
let zcZ = zeroCrossings(zArr);
let avgZC = (zcX + zcY + zcZ)/3;

/* --- 3. Micro Activity Ratio --- */
let activeSamples=0;
for(let i=0;i<xArr.length;i++){
if(Math.abs(xArr[i])>0.05 || Math.abs(yArr[i])>0.05 || Math.abs(zArr[i])>0.05){
activeSamples++;
}
}
let activityRatio = activeSamples/xArr.length;

/* --- 4. Axis Spread --- */
let axisSpread = Math.max(stdX,stdY,stdZ) - Math.min(stdX,stdY,stdZ);

/* --- Scoring --- */
let score=0;

if(avgStd > 0.05) score+=1;
if(avgZC > 15) score+=1;
if(activityRatio > 0.35) score+=1;
if(axisSpread > 0.01) score+=1;

let tremorDetected = score >= 3;

/* Challenge Display Only */
let totalDist=0;
for(let p of points){
totalDist+=pointToLineDistance(p,challengeLine);
}
let avgDist=points.length?totalDist/points.length:999;
let challengePercent = Math.max(0, 100 - avgDist*5);
challengePercent = Math.min(100, challengePercent);

document.getElementById("challengeScore").innerHTML=
"Challenge Accuracy: "+challengePercent.toFixed(0)+"%";

if(tremorDetected){
document.getElementById("result").innerHTML="LIVE HUMAN DETECTED";
document.getElementById("badge").innerHTML=
"Neural Variability Pattern Confirmed";
document.getElementById("card").classList.add("success");
}else{
document.getElementById("result").innerHTML="NOT HUMAN";
document.getElementById("badge").innerHTML=
"No Micro-Physiological Variability";
document.getElementById("card").classList.add("fail");
}

}

function pointToLineDistance(p,line){
let A=line.y2-line.y1;
let B=line.x1-line.x2;
let C=line.x2*line.y1-line.x1*line.y2;
return Math.abs(A*p.x+B*p.y+C)/Math.sqrt(A*A+B*B);
}

function drawGraphs(){
drawLine("graphX",xArr,"#ff4d4d");
drawLine("graphY",yArr,"#4dff88");
drawLine("graphZ",zArr,"#4da6ff");
}

function drawLine(id,data,color){
let c=document.getElementById(id);
let ctx=c.getContext("2d");
ctx.clearRect(0,0,c.width,c.height);
ctx.strokeStyle=color;
ctx.beginPath();
for(let i=0;i<data.length;i++){
let x=i;
let y=30-data[i]*10;
if(i===0)ctx.moveTo(x,y);
else ctx.lineTo(x,y);
}
ctx.stroke();
}

let ch=document.getElementById("challenge");
let ctx=ch.getContext("2d");

function drawChallenge(){
ctx.clearRect(0,0,320,120);
ctx.strokeStyle="#00ffd0";
ctx.lineWidth=3;
ctx.beginPath();
ctx.moveTo(challengeLine.x1,challengeLine.y1);
ctx.lineTo(challengeLine.x2,challengeLine.y2);
ctx.stroke();
}

ch.addEventListener("touchmove",function(e){
e.preventDefault();
let rect=ch.getBoundingClientRect();
let x=e.touches[0].clientX-rect.left;
let y=e.touches[0].clientY-rect.top;
points.push({x,y});
ctx.fillStyle="white";
ctx.fillRect(x,y,3,3);
});

</script>
</body>
</html>
